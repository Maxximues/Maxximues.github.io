<!DOCTYPE html>
<html lang="zh-hans">
  <head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8">
<!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Binary Tree Day one"><link rel="alternate" href="/atom.xml" title="Hexo"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="http://yoursite.com/2019/07/18/Binary-Tree/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css"><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":true};
</script>

    <title>Binary Tree Day one - Hexo</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="mobile-header-logo">
    <a href="/." class="logo">Hexo</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Hexo</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Binary Tree Day one
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-07-18
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#数据结构“树与二叉树”的学习"><span class="toc-text">数据结构“树与二叉树”的学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一些学习心得"><span class="toc-text">一些学习心得</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树：包含n个结点的有限集"><span class="toc-text">树：包含n个结点的有限集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树：一种特殊的树"><span class="toc-text">二叉树：一种特殊的树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的性质"><span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的两种特殊形态："><span class="toc-text">二叉树的两种特殊形态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#满二叉树的特点"><span class="toc-text">满二叉树的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完全二叉树的特点"><span class="toc-text">完全二叉树的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两种特殊二叉树的重要特性"><span class="toc-text">两种特殊二叉树的重要特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的存储结构"><span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#顺序存储"><span class="toc-text">顺序存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链式存储"><span class="toc-text">链式存储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历二叉树"><span class="toc-text">遍历二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#根据遍历序列确定二叉树"><span class="toc-text">根据遍历序列确定二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树遍历算法的应用"><span class="toc-text">二叉树遍历算法的应用</span></a></li></ol>
    </div>
  </div><div class="post-content"><h1 id="数据结构“树与二叉树”的学习"><a href="#数据结构“树与二叉树”的学习" class="headerlink" title="数据结构“树与二叉树”的学习"></a>数据结构“树与二叉树”的学习</h1><hr>
<h4 id="一些学习心得"><a href="#一些学习心得" class="headerlink" title="一些学习心得"></a>一些学习心得</h4><a id="more"></a>
<h3 id="树：包含n个结点的有限集"><a href="#树：包含n个结点的有限集" class="headerlink" title="树：包含n个结点的有限集"></a>树：包含n个结点的有限集</h3><ul>
<li>有且仅有一个 root 结点</li>
<li>除了 root 结点以外的其余结点可以分为许多的不相交的有限集，而这些有限集本身也是一棵树，因此可以称为 root 的子树。<h3 id="二叉树：一种特殊的树"><a href="#二叉树：一种特殊的树" class="headerlink" title="二叉树：一种特殊的树"></a>二叉树：一种特殊的树</h3></li>
<li>同样有且只有一个 root 结点</li>
<li>但是不同于树，其每一个结点只有两个互不相交的子集，分别称为左子树和右子树（不能颠倒顺序），且左，右子树本身也属于二叉树。<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3></li>
<li>二叉树的第 i 层最多有 $2^{i-1}$ 个结点</li>
<li>深度为 k 的二叉树至多有 $2{i-2}$ 个结点</li>
<li>任何一颗二叉树，叶子结点 $n_0$ 的个数等于度为 2 的结点 $n_2$ 个数 + 1。<h3 id="二叉树的两种特殊形态："><a href="#二叉树的两种特殊形态：" class="headerlink" title="二叉树的两种特殊形态："></a>二叉树的两种特殊形态：</h3></li>
<li>满二叉树</li>
<li>完全二叉树</li>
</ul>
<h3 id="满二叉树的特点"><a href="#满二叉树的特点" class="headerlink" title="满二叉树的特点"></a>满二叉树的特点</h3><ul>
<li>每一层的结点数都是最大结点数，即 $2^{i-1}$ 个<h3 id="完全二叉树的特点"><a href="#完全二叉树的特点" class="headerlink" title="完全二叉树的特点"></a>完全二叉树的特点</h3></li>
<li>首先对满二叉树的结点进行编号，以root结点开始，从上往下，从左往右。假设深度为 k d，有 n 个结点的二叉树，当且仅当其中每一个结点都与深度为 k 的满二叉树中的编号从 1 至 n 的结点一一对应使，才称为完全二叉树。</li>
</ul>
<h3 id="两种特殊二叉树的重要特性"><a href="#两种特殊二叉树的重要特性" class="headerlink" title="两种特殊二叉树的重要特性"></a>两种特殊二叉树的重要特性</h3><ul>
<li><p>具有 n 个结点的完全二叉树的深度为 $\lfloor log_2n\rfloor$ +1。</p>
</li>
<li><p>如果对一棵有 n 个结点的完全二叉树（ 其深度为 $\lfloor log_2n\rfloor$ +1 ）的结点按层序编号，则对任一结点 i（ $1\leq i \leq n$ ），有<br></p>
<ol>
<li>如果 i = 1，则结点 i 是二叉树的根，无双亲；如果 $i&gt;1$，则其双亲PARENT（i）是结点 $\lfloor i/2 \rfloor$。</li>
<li>如果 2i&gt;n，则结点 i 无左孩子；否则其左孩子是结点 2i。</li>
<li>如果 2i+1&gt;n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3></li>
</ol>
</li>
<li><p>顺序存储</p>
</li>
<li><p>链式存储</p>
<h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXISIEZE 100;</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAXSIZE];</span><br><span class="line"><span class="comment">// TElemType 在实际编程中换成所需的类型</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种存储结构仅适用于完全二叉树，对于结点数很少的树来说是非常浪费存储空间的</p>
</li>
</ul>
<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>  <span class="comment">// 用于指向前驱和后继</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<ul>
<li>在含有 n 个结点的二叉链表中有 n+1 个空链域<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n 个节点，每个结点 2 个指针域，共 2n 个指针域，</span><br><span class="line">用掉 n-1 个指针域，剩下 2n - ( n - 1 ) 个指针域。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><blockquote>
<p>二叉树遍历的关键在于<strong>递归</strong>思想。<br></p>
</blockquote>
<p>规定先先左后右，分为三种情况：</p>
<ul>
<li>先（根）序遍历（DLR）<ol>
<li>先访问根结点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树 </li>
</ol>
</li>
<li>中（根）序遍历（LDR）<ol>
<li>中序遍历左子树</li>
<li>访问根结点</li>
<li>中序遍历右子树</li>
</ol>
</li>
<li>后（根）序遍历（LRD）<ol>
<li>后序遍历左子树</li>
<li>后续遍历右子树</li>
<li>访问根节点</li>
</ol>
</li>
</ul>
<p>例：中序遍历的递归算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T) &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span class="built_in">std</span>::ends;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：中序遍历的非递归算法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse_N</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    StackNode *S;</span><br><span class="line">    BiTNode *p,*q;</span><br><span class="line">    Initalize_Link(S);</span><br><span class="line">    p = T;</span><br><span class="line">    q = <span class="keyword">new</span> BiTNode;</span><br><span class="line">    <span class="keyword">while</span>(p||S) &#123; <span class="comment">// S表示存储二叉树data的栈不为空</span></span><br><span class="line">        <span class="keyword">if</span>(p) &#123;</span><br><span class="line">            Push_Link(S, p-&gt;data);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Pop_Link(S, q-&gt;data);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;q-&gt;data;</span><br><span class="line">            p=q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是递归还是非递归算法，对于 n 个结点的二叉树，其时间复杂度均为O(n)，空间复杂度也为O(n)。</p>
<h3 id="根据遍历序列确定二叉树"><a href="#根据遍历序列确定二叉树" class="headerlink" title="根据遍历序列确定二叉树"></a>根据遍历序列确定二叉树</h3><ul>
<li>中序遍历 + 先序遍历</li>
<li>中序遍历 + 后序遍历</li>
</ul>
<p>方法：先利用先(后)序序列，找到根结点。然后根据中序序列找到根节点的左，右子树，再在先序序列中取第二个结点（后序序列取倒数第二个结点），根据同样的方式，继续分割中序序列，一直递归直至完成。<br><em>注意：先序序列第一个结点就是根结点，后序序列最后一个结点是根结点。</em></p>
<p>例如：已知一棵二叉树的中序序列和后序序列分别是 BDCEAFHG 和 DECBHGFA，请画出这棵二叉树</p>
<ul>
<li>第一步：根据后续序列 DECBHGFA 的最后一个结点，可以得到根结点为 A 为根结点</li>
<li>第二步：在中序序列中找到 根结点 A 两侧的左，右子树 E 和 F。此时中序序列被分成两部分 左子树部分 BDCE，和右子树部分 FHG。后序序列也被分成左，右子树两部分，DECB 和 HGF。</li>
<li>第三步：先看左子树的中序序列 BDCE，得到这部分的根节点是 B（A已经考虑完了，不再考虑），左子树的中序序列 BDCE 表示 B 结点只有右子树，是 CDE。同理，按这种方法不断递归，就可以得到一棵完整的二叉树。</li>
</ul>
<h3 id="二叉树遍历算法的应用"><a href="#二叉树遍历算法的应用" class="headerlink" title="二叉树遍历算法的应用"></a>二叉树遍历算法的应用</h3><p>先序遍历的顺序建立二叉链表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">'#'</span>) T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        T = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;              <span class="comment">// 输出根节点    </span></span><br><span class="line">        CreateBiTree(T-&gt;lchild); <span class="comment">// 递归创建左子树 </span></span><br><span class="line">        CreateBiTree(T-&gt;rchild); <span class="comment">// 递归创建右子树     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>中序遍历和后序遍历只需要改变最后三个语句的顺序即可</em></p>
<p>复制二叉树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BiTree T, BiTree &amp;NewT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        NewT = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NewT = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        NewT-&gt;data = T-&gt;data;</span><br><span class="line">        Copy(T-&gt;lchild, NewT-&gt;lchild);</span><br><span class="line">        Copy(T-&gt;rchild, NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算二叉树的深度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的深度等于左右子树深度较大的加 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    m = n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        m = Depth(T-&gt;lchild);</span><br><span class="line">        n = Depth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;m) <span class="keyword">return</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (m+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>统计二叉书的结点个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的个数等于左右子树结点数 + 1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://yoursite.com">Je Ano</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://yoursite.com/2019/07/18/Binary-Tree/">http://yoursite.com/2019/07/18/Binary-Tree/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        
        <nav class="post-nav"></nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="https://github.com/Maxximues" class="iconfont icon-github" title="github"></a>
        <a href="https://www.zhihu.com/people/xi-si-lai-si-jie/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Je Ano</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
