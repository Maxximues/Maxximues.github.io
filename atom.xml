<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ano Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://maxximues.github.io/"/>
  <updated>2019-10-01T00:13:58.548Z</updated>
  <id>http://maxximues.github.io/</id>
  
  <author>
    <name>Je Ano</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KMP</title>
    <link href="http://maxximues.github.io/2019/09/30/KMP/"/>
    <id>http://maxximues.github.io/2019/09/30/KMP/</id>
    <published>2019-09-30T10:47:28.000Z</published>
    <updated>2019-10-01T00:13:58.548Z</updated>
    
    <content type="html"><![CDATA[<p>对于模式串的常规匹配算法通常时间复杂度很大，效率不高。因此 D. E. Knuth 与 V. R. Partt 和 J. H. Morris 同时发现了一种改进算法，称之为Knuth-Partt-Morris 算法，简称 KMP 算法。此算法的时间复杂度可以达到 $O(m+n)$。</p><a id="more"></a><p>在 KMP 算法中最为重要的就是得到前缀表Prefix table，用来存储在不同位置上匹配失败时子串后移的距离，用一个一维数组表示(数组的实际存储下标从1开始)。<br>模式串：</p><table><thead><tr><th>A</th><th>B</th><th>A</th><th>B</th><th>A</th><th>B</th><th>B</th></tr></thead></table><p>用该模式串来匹配主串时，存在7个不同位置的匹配失败，得到下列几种子串(最后一个字母匹配失败)：</p><table><thead><tr><th>A</th><th>B</th><th>A</th><th>B</th><th>A</th><th>B</th><th>B</th></tr></thead><tbody><tr><td>A</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>A</td><td>B</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>A</td><td>B</td><td>A</td><td></td><td></td><td></td><td></td></tr><tr><td>A</td><td>B</td><td>A</td><td>B</td><td></td><td></td><td></td></tr><tr><td>A</td><td>B</td><td>A</td><td>B</td><td>A</td><td></td><td></td></tr><tr><td>A</td><td>B</td><td>A</td><td>B</td><td>A</td><td>B</td><td></td></tr><tr><td>A</td><td>B</td><td>A</td><td>B</td><td>A</td><td>B</td><td>B</td></tr></tbody></table><p>子串头开始的子串为前缀，不匹配处往前的子串称之为后缀，当该字串的最大公共前缀等于其最大公共后缀时得到的公共子串称之为最大公共最大子串。<br>以上7种子串的最大公共子串分别是(0 表示没有)：</p><table><thead><tr><th>0</th><th>0</th><th>0</th><th>A</th><th>AB</th><th>ABA</th><th>ABAB</th></tr></thead></table><p>这7种子串的最大公共子串长度分别是: </p><table><thead><tr><th>0</th><th>0</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead></table><p>在不匹配时，将公共前缀移到公共后缀位置，也就是最大公共子串的长度+1，即可得到前缀表Prefix table</p><table><thead><tr><th>0</th><th>1</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead></table><p>用C/C++代码描述</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnext</span><span class="params">(Str substr, <span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; substr.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || substr.ch[i] == substr.ch[j])&#123;</span><br><span class="line">            <span class="comment">// j == 0 保证了next[i]的值一定大于等于1，因为这个数组下标从1开始</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            j = next[j];</span><br><span class="line">            <span class="comment">// 这里使用了动态规划进行优化，也可以使用常规方法，j--;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于模式串的常规匹配算法通常时间复杂度很大，效率不高。因此 D. E. Knuth 与 V. R. Partt 和 J. H. Morris 同时发现了一种改进算法，称之为Knuth-Partt-Morris 算法，简称 KMP 算法。此算法的时间复杂度可以达到 $O(m+n)$。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面向正则表达式编程的Perl</title>
    <link href="http://maxximues.github.io/2019/07/21/%E9%9D%A2%E5%90%91%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84Perl/"/>
    <id>http://maxximues.github.io/2019/07/21/面向正则表达式编程的Perl/</id>
    <published>2019-07-21T12:11:31.000Z</published>
    <updated>2019-07-23T21:39:59.366Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://www.kiffingish.com/images/poweredby/perl-logo.png" alt="Perl"></p><p>单个查找替换效率低下，于是就想着是否有方便的工具，但是不想使用 $Python$，就考虑到 $Perl$，虽然 $Perl$ 相对来说古怪一些，但是在接触以后，发现它还是很强大的，而且充满了乐趣。以下作为学习 $Perl$ 中的 $RegEx$ 的一些记录。</p><a id="more"></a><h2 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h2><blockquote><p>A regular expression, regex or regexp (sometimes called a rational expression)is a sequence of characters that define a search pattern. Usually such patterns are used by string searching algorithms for “find” or “find and replace” operations on strings, or for input validation. It is a technique developed in theoretical computer science and formal language theory.</p></blockquote><p>以上是WiKipedia上的定义，也就是说正则表达式是一种特殊的字符序列，可以用来定义如何搜索匹配样本。</p><p>在 Perl 中，通常使用 <strong>/ /</strong> 来界定匹配样本(实际上是 m//, m通常可以省略 )。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ab/     <span class="comment"># 表示匹配 ab 字符串</span></span><br></pre></td></tr></table></figure><p>但是如果在匹配源中本身就存在 /字符时，整个匹配样本就显得难以区分。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/http:\/\//  <span class="comment"># \字符用于转义 /字符</span></span><br></pre></td></tr></table></figure><p>实际上Perl对 <strong>/ /</strong> 并不做硬性的要求，因此只要是使用成对的定界符即可，比如</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">m</span>%http:\/\/% <span class="keyword">or</span> <span class="keyword">m</span>&#123;http:\/\/&#125;</span><br></pre></td></tr></table></figure><p>这些都可以达到一样的效果。<br>如何对特定变量进行正则匹配呢？这时就需要使用捆绑操作符（the binding operator ）=~ 。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">my</span> $one_url = <span class="string">"https://maxximues.github.io"</span>;</span><br><span class="line"><span class="keyword">if</span>($one_url =~ <span class="regexp">/^http:\/\//</span>) &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"这是一个URL\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>^表示从头开始匹配</em></p><h2 id="捷径—方便用于正则匹配中的”记号”"><a href="#捷径—方便用于正则匹配中的”记号”" class="headerlink" title="捷径—方便用于正则匹配中的”记号”"></a>捷径—方便用于正则匹配中的”记号”</h2><ul><li><p>. —用于匹配任意单个字符，除新的一行以外。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/ab.a/ <span class="comment"># 可以用于匹配 abaa，abba....</span></span><br></pre></td></tr></table></figure></li><li><p>重复词Quantifiers</p></li></ul><table><thead><tr><th>Number to match</th><th>Metacharacter</th><th>Generalized form</th></tr></thead><tbody><tr><td>Optional</td><td>?</td><td>{0,1}</td></tr><tr><td>Zero or more</td><td>*</td><td>{0,}</td></tr><tr><td>One or more</td><td>+</td><td>{1,}</td></tr><tr><td>Minimum or more</td><td></td><td>{min,}</td></tr><tr><td>Minimum with maximum</td><td></td><td>{min,max}</td></tr><tr><td>Exactly</td><td></td><td>{exactly_number}</td></tr></tbody></table><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/abb?a/ <span class="comment"># 匹配 abba 或者 aba</span></span><br><span class="line">/abb*a/ <span class="comment"># 匹配 aba 或者 abba，abbba，abb...ba</span></span><br><span class="line">/abb+a/ <span class="comment"># 匹配 abba 或者 abbba，abbb...ba</span></span><br><span class="line">/abb&#123;<span class="number">2</span>,<span class="number">3</span>&#125;a/ <span class="comment"># 匹配 abbba，abbbba</span></span><br><span class="line">/abb<span class="string">&#123;4&#125;</span>a/ <span class="comment"># 匹配 abbbbba</span></span><br></pre></td></tr></table></figure><p>重复词只能将它最邻近字符重复匹配。</p><ul><li>分组Group</li></ul><p>如何将特定字段重复匹配呢？使用 () 将需要可能重复的字段囊括起来。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/fred&#123;<span class="number">1</span>,<span class="number">2</span>&#125;/ <span class="comment"># 匹配 fred,fredd</span></span><br><span class="line">/(fred)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;/ <span class="comment"># 匹配 fred 或者 fredfred</span></span><br></pre></td></tr></table></figure><p>且根据括号使用的先后，可以使用\num，来代表这组匹配，num表示第几个出现的括号</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> v5.<span class="number">10</span>;</span><br><span class="line"><span class="keyword">my</span> $str = <span class="string">"Fred anda and Fred anda are my friends."</span>;</span><br><span class="line"><span class="keyword">if</span>($str =~ <span class="regexp">/(Fred) (anda) and \1 \2/</span>) &#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Yes"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/07/23/ekcNo4.png" alt="ekcNo4.png"></p><p>当括号使用次数很多时，使用 <em>\num</em> 这种方式就很容易出错，所以在v5.10版本后，可以使用 <em>\g{num}</em> 来清楚指定第几个括号中的内容，且不容和匹配源中的文字产生歧义。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/(.)\<span class="number">111</span>/ <span class="comment"># 这时就会产生歧义，\1 \11 \111 这三个都可能是</span></span><br><span class="line">/(.)\g<span class="string">&#123;1&#125;</span><span class="number">11</span>/ <span class="comment"># 这是就准确表示匹配 (.)(.)11</span></span><br></pre></td></tr></table></figure><ul><li><p>可选词Alternatives</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/fred|barney/</span><br></pre></td></tr></table></figure></li><li><p>字符类Character Classes</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/[a-z]/ <span class="comment"># 表示一个小写字母 a-z 的匹配</span></span><br><span class="line">/[A-Z]/ <span class="comment"># 表示一个大写字母 A-Z 的匹配</span></span><br><span class="line">/[<span class="number">0</span>-<span class="number">9</span>]/ <span class="comment"># 表示一个数字 0-9 的匹配</span></span><br><span class="line">/[A-Z]+<span class="regexp">/ # 表示大写字母 A-Z 的匹配</span></span><br></pre></td></tr></table></figure></li></ul><p>事实上在使用时这些也有一些简便方法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/[<span class="number">0</span>-<span class="number">9</span>]/ == <span class="regexp">/\d/</span> <span class="comment"># decimal digits</span></span><br><span class="line">/[a-zA-Z]/ == <span class="regexp">/\D/</span> <span class="comment"># not a decimal digit</span></span><br><span class="line">/ <span class="regexp">/ == /</span>\<span class="keyword">s</span>/ <span class="comment"># whitespace</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>定位开头末尾的”锚”Anchors<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^w<span class="string">&#123;3&#125;</span>\.(\w)+@(\w)+\.com(\.cn)?$/ <span class="comment"># ^表示字符串开头匹配，$表示字符串末尾匹配，整体匹配一个邮箱</span></span><br></pre></td></tr></table></figure></li></ul><p><img src="https://s2.ax1x.com/2019/07/24/eAsWCR.png" alt="eAsWCR.png"><br>在Perl 5中，也可以使用 <em>\A</em> 和 <em>\Z</em>来分别表示开头和末尾。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://www.kiffingish.com/images/poweredby/perl-logo.png&quot; alt=&quot;Perl&quot;&gt;&lt;/p&gt;
&lt;p&gt;单个查找替换效率低下，于是就想着是否有方便的工具，但是不想使用 $Python$，就考虑到 $Perl$，虽然 $Perl$ 相对来说古怪一些，但是在接触以后，发现它还是很强大的，而且充满了乐趣。以下作为学习 $Perl$ 中的 $RegEx$ 的一些记录。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>树和森林</title>
    <link href="http://maxximues.github.io/2019/07/20/%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/"/>
    <id>http://maxximues.github.io/2019/07/20/树和森林/</id>
    <published>2019-07-20T06:20:57.000Z</published>
    <updated>2019-07-20T11:14:10.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><hr><a id="more"></a><ul><li>双亲表示法</li><li>孩子表示法</li><li>孩子兄弟表示法</li></ul><h4 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h4><p>用一组联系的存储单元存储树的结点，每个结点包含<em>数据域 data</em> 用于存储数据和<em>双亲域 parent</em> 用于指向其双亲（父节点）。</p><table><thead><tr><th>data</th><th>parent</th></tr></thead></table><p>原理：利用了每个结点只有唯一一个双亲（父节点）的性质。</p><h4 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h4><p>树中每个结点有多棵子树，每个结点包含一个<em>数据域 data</em> 和多个<em>指针域 $child_n$</em>。</p><table><thead><tr><th>data</th><th>$child_1$</th><th>$child_2$</th><th>$child_3$</th><th>…</th><th>$child_d$</th></tr></thead></table><p><em>d</em>表示树的度。<br>缺点：很多的结点度都是小于 d 的，所以有很多的空链域，即在一棵 n 个结点度为 k 的树中必有 n(k-1)+1 个空链域。</p><h4 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h4><p>也称为二叉链表表示法，树中的每一个结点包含一个<em>数据域 data</em> 和两个<em>指针域 firstchild</em> 指向第一个孩子和 <em>nextsibling</em> 指向下一兄弟。</p><table><thead><tr><th>firstchild</th><th>data</th><th>nextsibling</th></tr></thead></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> &#123;</span></span><br><span class="line">    Elemtype data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">fiestchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode, *CSTree；</span><br></pre></td></tr></table></figure><h3 id="森林与二叉树的转换"><a href="#森林与二叉树的转换" class="headerlink" title="森林与二叉树的转换"></a>森林与二叉树的转换</h3><p>任何一棵和树对应的二叉树，其根结点的右子树必定是空。<br>把森林中第二棵树的根结点看成是第一棵树的根结点的兄弟，就可以推导出森林与二叉树的对应关系。</p><ul><li>森林转换成二叉树<br>  $F$ = { $T_1$, $T_2$, …$T_m$ }是森林，将其转化成一棵二叉树 $B$ = ( $root$, $LB$, $RB$ )。<ol><li>若 $F$ 为空，即 $m = 0$，则 $B$ 为空树。</li><li>若 $F$ 非空，即 $m \neq 0$,则 $B$ 的根 $root$ 即为森林中第一棵树的根 $ROOT$($T_1$); $B$ 的左子树 $LB$ 是从 $T_1$ 中根结点的子树森林 $F_1$ = {$T_{11}$, $T_{12}$, … ,$T_{1m}$}转换而成的二叉树；其右子树 $RB$ 是从森林 $F’$ = { $T_2$, $T_3$, …, $T_m$}转换而成的二叉树。</li></ol></li><li>二叉树转换成森林<br>  $B$ = ( $root$, $LB$, $RB$ )一棵二叉树，将其转化成森林 $F$ = { $T_1$, $T_2$, …$T_m$ }<ol><li>若 $B$ 为空，则 $F$ 为空。</li><li>若 $B$ 非空，则 $F$ 中第一棵树 $T_1$ 的根 $ROOT(T_1)$ 即为二叉树 $B$ 的根 $root$；$T_1$ 中的根结点的子树森林 $F_1$ 是由 $B$ 的左子树 $LB$ 转换而成的森林； $F$ 中除 $T_1$ 之外其余树组成的森林 $F’$ = { $T_2$, $T_3$, …, $T_m$ }是由 $B$ 的右子树 $RB$ 转换而成的森林。</li></ol></li></ul><p>无论是森林转二叉树，还是二叉树转森林，其核心都是<strong>递归思想</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;树的存储结构&quot;&gt;&lt;a href=&quot;#树的存储结构&quot; class=&quot;headerlink&quot; title=&quot;树的存储结构&quot;&gt;&lt;/a&gt;树的存储结构&lt;/h2&gt;&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Binary Tree</title>
    <link href="http://maxximues.github.io/2019/07/18/Binary-Tree/"/>
    <id>http://maxximues.github.io/2019/07/18/Binary-Tree/</id>
    <published>2019-07-18T01:19:11.000Z</published>
    <updated>2019-07-19T13:00:33.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构“树与二叉树”的学习"><a href="#数据结构“树与二叉树”的学习" class="headerlink" title="数据结构“树与二叉树”的学习"></a>数据结构“树与二叉树”的学习</h1><hr><h4 id="一些学习心得"><a href="#一些学习心得" class="headerlink" title="一些学习心得"></a>一些学习心得</h4><a id="more"></a><h3 id="树：包含n个结点的有限集"><a href="#树：包含n个结点的有限集" class="headerlink" title="树：包含n个结点的有限集"></a>树：包含n个结点的有限集</h3><ul><li>有且仅有一个 root 结点</li><li>除了 root 结点以外的其余结点可以分为许多的不相交的有限集，而这些有限集本身也是一棵树，因此可以称为 root 的子树。<h3 id="二叉树：一种特殊的树"><a href="#二叉树：一种特殊的树" class="headerlink" title="二叉树：一种特殊的树"></a>二叉树：一种特殊的树</h3></li><li>同样有且只有一个 root 结点</li><li>但是不同于树，其每一个结点只有两个互不相交的子集，分别称为左子树和右子树（不能颠倒顺序），且左，右子树本身也属于二叉树。<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3></li><li>二叉树的第 i 层最多有 $2^{i-1}$ 个结点</li><li>深度为 k 的二叉树至多有 $2{i-2}$ 个结点</li><li>任何一颗二叉树，叶子结点 $n_0$ 的个数等于度为 2 的结点 $n_2$ 个数 + 1。<h3 id="二叉树的两种特殊形态："><a href="#二叉树的两种特殊形态：" class="headerlink" title="二叉树的两种特殊形态："></a>二叉树的两种特殊形态：</h3></li><li>满二叉树</li><li>完全二叉树</li></ul><h3 id="满二叉树的特点"><a href="#满二叉树的特点" class="headerlink" title="满二叉树的特点"></a>满二叉树的特点</h3><ul><li>每一层的结点数都是最大结点数，即 $2^{i-1}$ 个<h3 id="完全二叉树的特点"><a href="#完全二叉树的特点" class="headerlink" title="完全二叉树的特点"></a>完全二叉树的特点</h3></li><li>首先对满二叉树的结点进行编号，以root结点开始，从上往下，从左往右。假设深度为 k d，有 n 个结点的二叉树，当且仅当其中每一个结点都与深度为 k 的满二叉树中的编号从 1 至 n 的结点一一对应使，才称为完全二叉树。</li></ul><h3 id="两种特殊二叉树的重要特性"><a href="#两种特殊二叉树的重要特性" class="headerlink" title="两种特殊二叉树的重要特性"></a>两种特殊二叉树的重要特性</h3><ul><li><p>具有 n 个结点的完全二叉树的深度为 $\lfloor log_2n\rfloor$ +1。</p></li><li><p>如果对一棵有 n 个结点的完全二叉树（ 其深度为 $\lfloor log_2n\rfloor$ +1 ）的结点按层序编号，则对任一结点 i（ $1\leq i \leq n$ ），有<br></p><ol><li>如果 i = 1，则结点 i 是二叉树的根，无双亲；如果 $i&gt;1$，则其双亲PARENT（i）是结点 $\lfloor i/2 \rfloor$。</li><li>如果 2i&gt;n，则结点 i 无左孩子；否则其左孩子是结点 2i。</li><li>如果 2i+1&gt;n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3></li></ol></li><li><p>顺序存储</p></li><li><p>链式存储</p><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXISIEZE 100;</span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAXSIZE];</span><br><span class="line"><span class="comment">// TElemType 在实际编程中换成所需的类型</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure></li><li><p>这种存储结构仅适用于完全二叉树，对于结点数很少的树来说是非常浪费存储空间的</p></li></ul><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>  <span class="comment">// 用于指向前驱和后继</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><ul><li>在含有 n 个结点的二叉链表中有 n+1 个空链域<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n 个节点，每个结点 2 个指针域，共 2n 个指针域，</span><br><span class="line">用掉 n-1 个指针域，剩下 2n - ( n - 1 ) 个指针域。</span><br></pre></td></tr></table></figure></li></ul><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><blockquote><p>二叉树遍历的关键在于<strong>递归</strong>思想。<br></p></blockquote><p>规定先先左后右，分为三种情况：</p><ul><li>先（根）序遍历（DLR）<ol><li>先访问根结点</li><li>先序遍历左子树</li><li>先序遍历右子树 </li></ol></li><li>中（根）序遍历（LDR）<ol><li>中序遍历左子树</li><li>访问根结点</li><li>中序遍历右子树</li></ol></li><li>后（根）序遍历（LRD）<ol><li>后序遍历左子树</li><li>后续遍历右子树</li><li>访问根节点</li></ol></li></ul><p>例：中序遍历的递归算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T) &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;T-&gt;data&lt;&lt;<span class="built_in">std</span>::ends;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：中序遍历的非递归算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse_N</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    StackNode *S;</span><br><span class="line">    BiTNode *p,*q;</span><br><span class="line">    Initalize_Link(S);</span><br><span class="line">    p = T;</span><br><span class="line">    q = <span class="keyword">new</span> BiTNode;</span><br><span class="line">    <span class="keyword">while</span>(p||S) &#123; <span class="comment">// S表示存储二叉树data的栈不为空</span></span><br><span class="line">        <span class="keyword">if</span>(p) &#123;</span><br><span class="line">            Push_Link(S, p-&gt;data);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Pop_Link(S, q-&gt;data);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;q-&gt;data;</span><br><span class="line">            p=q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论是递归还是非递归算法，对于 n 个结点的二叉树，其时间复杂度均为O(n)，空间复杂度也为O(n)。</p><h3 id="根据遍历序列确定二叉树"><a href="#根据遍历序列确定二叉树" class="headerlink" title="根据遍历序列确定二叉树"></a>根据遍历序列确定二叉树</h3><ul><li>中序遍历 + 先序遍历</li><li>中序遍历 + 后序遍历</li></ul><p>方法：先利用先(后)序序列，找到根结点。然后根据中序序列找到根节点的左，右子树，再在先序序列中取第二个结点（后序序列取倒数第二个结点），根据同样的方式，继续分割中序序列，一直递归直至完成。<br><em>注意：先序序列第一个结点就是根结点，后序序列最后一个结点是根结点。</em></p><p>例如：已知一棵二叉树的中序序列和后序序列分别是 BDCEAFHG 和 DECBHGFA，请画出这棵二叉树</p><ul><li>第一步：根据后续序列 DECBHGFA 的最后一个结点，可以得到根结点为 A 为根结点</li><li>第二步：在中序序列中找到 根结点 A 两侧的左，右子树 E 和 F。此时中序序列被分成两部分 左子树部分 BDCE，和右子树部分 FHG。后序序列也被分成左，右子树两部分，DECB 和 HGF。</li><li>第三步：先看左子树的中序序列 BDCE，得到这部分的根节点是 B（A已经考虑完了，不再考虑），左子树的中序序列 BDCE 表示 B 结点只有右子树，是 CDE。同理，按这种方法不断递归，就可以得到一棵完整的二叉树。</li></ul><h3 id="二叉树遍历算法的应用"><a href="#二叉树遍历算法的应用" class="headerlink" title="二叉树遍历算法的应用"></a>二叉树遍历算法的应用</h3><p>先序遍历的顺序建立二叉链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">'#'</span>) T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        T = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;              <span class="comment">// 输出根节点    </span></span><br><span class="line">        CreateBiTree(T-&gt;lchild); <span class="comment">// 递归创建左子树 </span></span><br><span class="line">        CreateBiTree(T-&gt;rchild); <span class="comment">// 递归创建右子树     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>中序遍历和后序遍历只需要改变最后三个语句的顺序即可</em></p><p>复制二叉树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Copy</span><span class="params">(BiTree T, BiTree &amp;NewT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        NewT = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NewT = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        NewT-&gt;data = T-&gt;data;</span><br><span class="line">        Copy(T-&gt;lchild, NewT-&gt;lchild);</span><br><span class="line">        Copy(T-&gt;rchild, NewT-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算二叉树的深度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的深度等于左右子树深度较大的加 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    m = n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        m = Depth(T-&gt;lchild);</span><br><span class="line">        n = Depth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(n&gt;m) <span class="keyword">return</span>(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (m+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统计二叉书的结点个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树的个数等于左右子树结点数 + 1。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) +<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构“树与二叉树”的学习&quot;&gt;&lt;a href=&quot;#数据结构“树与二叉树”的学习&quot; class=&quot;headerlink&quot; title=&quot;数据结构“树与二叉树”的学习&quot;&gt;&lt;/a&gt;数据结构“树与二叉树”的学习&lt;/h1&gt;&lt;hr&gt;
&lt;h4 id=&quot;一些学习心得&quot;&gt;&lt;a href=&quot;#一些学习心得&quot; class=&quot;headerlink&quot; title=&quot;一些学习心得&quot;&gt;&lt;/a&gt;一些学习心得&lt;/h4&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
